Aim:-Write a program to implement matrix multiplication and discuss the time 
complexity of the algorithm.

m = int(input("Enter number of rows matrix1: "))
n = int(input("Enter number of columns matrix1: "))

mat1 = []

# creating no of rows for
for i in range(0, m):
    mat1.append([])

# creating no of columns for every rows
for i in range(0, m):
    for j in range(0, n):
        mat1[i].append(0)
        print("Entry in row:", i+1, "Column:", j+1)
        mat1[i][j] = int(input())

print(mat1)

p = int(input("Enter number of rows matrix2: "))
q = int(input("Enter number of columns matrix2: "))

mat2 = []

# creating no of rows for
for i in range(0, p):
    mat2.append([])

# creating no of columns for every rows
for i in range(0, p):
    for j in range(0, q):
        mat2[i].append(0)
        print("Entry in row:", i+1, "Column:", j+1)
        mat2[i][j] = int(input())

print(mat2)

if n != p:
    print("Multiplication not possible")
else:
    mat3 = []
    for i in range(0, m):
        mat3.append([])
        for j in range(0, q):
            mat3[i].append(0)
            for k in range(0, n):
                mat3[i][j] += mat1[i][k] * mat2[k][j]

    print("Multiplication result:")
    for row in mat3:
        print(row)

_______________________________________________________________________________________________________

Aim:-Write a program to implement quick sort algorithm and discuss the time 
complexity of the algorithm.

def quicksort(testlist, start, end):
    if start < end:
        pivot = partition(testlist, start, end)
        quicksort(testlist, start, pivot-1)
        quicksort(testlist, pivot+1, end)
    return testlist

def partition(testlist, start, end):
    pivot = testlist[end]
    i = start-1
    for j in range(start, end):
        if testlist[j] <= pivot:
            i += 1
            testlist[i], testlist[j] = testlist[j], testlist[i]
    testlist[i+1], testlist[end] = testlist[end], testlist[i+1]
    return i+1

list1 = [9,-3,5,2,6,8,-6,1,3]
print("List before sorting:", list1)
sorted_list = quicksort(list1, 0, len(list1)-1)
print("List after sorting:", sorted_list)

__________________________________________________________________________________________________

Aim:- Write a program to implement merge sort algorithm and discuss the 
time complexity of the algorithm.

def mergesort(mylist):
    print("Dividing:",mylist)
    if(len(mylist)>1):
        mid=len(mylist)//2
        Leftlist=mylist[:mid]
        Rightlist=mylist[mid:]
        mergesort(Leftlist)
        mergesort(Rightlist)
        i=0
        j=0
        k=0
        while(i<len(Leftlist) and (j<len(Rightlist))):
            if Leftlist[i]<=Rightlist[j]:
                mylist[k]=Leftlist[i]
                i=i+1
            else:
                mylist[k]=Rightlist[j]
                j=j+1
            k=k+1
        while i<len(Leftlist):
            mylist[k]=Leftlist[i]
            i=i+1
            k=k+1
        while j<len(Rightlist):
            mylist[k]=Rightlist[j]
            j=j+1
            k=k+1
        print("merging:",mylist)
    return mylist

num=int(input("How many number you want in list:"))
list1=[int(input())for x in range(num)]
mergesort(list1)
print("Sorted list: ",list1)

________________________________________________________________________________________________

Aim:-Write a program to implement Linear Search algorithm and discuss the 
time complexity of the algorithm.

def linearsearch(mylist, n, x):
    for i in range(n):
        if (mylist[i] == x):
            return i
    return -1

mylist = [2, 33, 45, 1, 30, 34, 56]
x = 1
n = len(mylist)
result = linearsearch(mylist, n, x)

if (result == -1):
    print("Element is not present in the list")
else:
    print("Element is present at index", result)

_________________________________________________________________________________________________

Aim:-Write a program to implement Binary Search algorithm and discuss the 
time complexity of the algorithm.

def binary_search(arr, low, high, x):
    if high >= low:
        mid = (high + low) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return binary_search(arr, low, mid - 1, x)
        else:
            return binary_search(arr, mid + 1, high, x)
    else:
        return -1

arr = [2, 3, 6, 8, 11, 13]
x = 3

print(arr)
print("X=", x)

result = binary_search(arr, 0, len(arr) - 1, x)

if result == -1:
    print("Element is not found")
else:
    print("Element is present at index", result)

_______________________________________________________________________________________________________

Aim:-Write a program to implement insertion operation on Binary Search tree 
and discuss the time complexity of the algorithm.

class Node:
    def __init__(self, index):
        self.left = None
        self.right = None
        self.val = index

def insert(root, newnode):
    if root is None:
        root = newnode
    else:
        if root.val <= newnode.val:
            if root.right is None:
                root.right = newnode
            else:
                insert(root.right, newnode)
        elif root.val == newnode.val:
            print("Already existing node ", newnode.val)
        else:
            if root.left is None:
                root.left = newnode
            else:
                insert(root.left, newnode)

def inorder(root):
    if root:
        if root.val is None:
            print(end="")
        else:
            inorder(root.left)
            print(root.val)
            inorder(root.right)

def preorder(root):
    if root:
        if root.val is None:
            print(end="")
        else:
            print(root.val)
            preorder(root.left)
            preorder(root.right)

def postorder(root):
    if root:
        if root.val is None:
            print(end="")
        else:
            postorder(root.left)
            postorder(root.right)
            print(root.val)

root = Node(100)
insert(root, Node(60))
insert(root, Node(50))
insert(root, Node(90))
insert(root, Node(40))
insert(root, Node(53))
insert(root, Node(95))
insert(root, Node(75))

print("Inorder Traversal:")
inorder(root)

print("Preorder Traversal:")
preorder(root)

print("Postorder Traversal:")
postorder(root)

print("\n")

__________________________________________________________________________________________

Aim:- Write a python program to delete node from the binary tree from a 
given data and discuss the time complexity.

class Node:
    def __init__(self, index):
        self.left = None
        self.right = None
        self.val = index

def insert(root, newnode):
    if root is None:
        root = newnode
    else:
        if root.val <= newnode.val:
            if root.right is None:
                root.right = newnode
            else:
                insert(root.right, newnode)
        elif root.val == newnode.val:
            print("Already existing node ", newnode.val)
        else:
            if root.left is None:
                root.left = newnode
            else:
                insert(root.left, newnode)

def inorder(root):
    if root:
        if root.val is None:
            print(end="")
        else:
            inorder(root.left)
            print(root.val, end=" ")
            inorder(root.right)

def preorder(root):
    if root:
        if root.val is None:
            print(end="")
        else:
            print(root.val, end=" ")
            preorder(root.left)
            preorder(root.right)

def postorder(root):
    if root:
        if root.val is None:
            print(end="")
        else:
            postorder(root.left)
            postorder(root.right)
            print(root.val, end=" ")

def delete(root, node1):
    if root is None:
        print("Empty tree")
    elif root.val < node1:
        delete(root.right, node1)
    elif root.val > node1:
        delete(root.left, node1)
    else:
        root.val = None

root = Node(100)
insert(root, Node(60))
insert(root, Node(50))
insert(root, Node(90))
insert(root, Node(40))
insert(root, Node(53))
insert(root, Node(95))
insert(root, Node(75))

print("Before Deletion Operation:")
print("Inorder Traversal:")
inorder(root)
print("\nPreorder Traversal:")
preorder(root)
print("\nPostorder Traversal:")
postorder(root)
print("\n")

delete(root, 40)
delete(root, 90)

print("After Deletion Operation:")
print("Inorder Traversal:")
inorder(root)
print("\nPreorder Traversal:")
preorder(root)
print("\nPostorder Traversal:")
postorder(root)

____________________________________________________________________________________________________

Aim:- Write a python program to implement Breadth First Traversal of graph.

def bfs(visited, graph, node): 
    visited.append(node) 
    queue = [node]
    while queue: 
        m = queue.pop(0) 
        print(m, end=" ") 
        for neighbour in graph[m]: 
            if neighbour not in visited: 
                visited.append(neighbour) 
                queue.append(neighbour) 

graph = { 
    'A': ['B', 'D', 'G'], 
    'B': ['A', 'C', 'D'], 
    'C': ['B', 'E', 'F'], 
    'D': ['A', 'B', 'E'], 
    'E': ['D', 'C', 'F', 'G'], 
    'F': ['C', 'E', 'H'], 
    'G': ['A', 'E', 'H'], 
    'H': ['G', 'F'], 
} 

visited=[] 
print("Following is Breadth-First Search") 
bfs(visited,graph,'A')

______________________________________________________________________________________________________

Aim:- Write a python program to implement Depth First Traversal of graph.

graph = { 
    'A': ['B', 'D', 'G'], 
    'B': ['A', 'C', 'D'], 
    'C': ['B', 'E', 'F'], 
    'D': ['A', 'B', 'E'], 
    'E': ['D', 'C', 'F', 'G'], 
    'F': ['C', 'E', 'H'], 
    'G': ['A', 'E', 'H'], 
    'H': ['G', 'F']
}
visited = set()

def dfs(visited, graph, node):
    if node not in visited:
        print(node, end=" ")
        visited.add(node)
        for neighbour in graph[node]:
            dfs(visited, graph, neighbour)

print("Following is the Depth-First Search")
dfs(visited, graph, 'A')

___________________________________________________________________________________________________

Aim:- Write python program for checking whether a given graph g has a simple 
path from source s to destination d

graph = {'A': ['B', 'C'], 
         'B': ['C', 'D'], 
         'C': ['D'], 
         'D': ['C'], 
         'E': ['F'], 
         'F': ['C']} 

def find_all_paths(graph, start, end, path=[]): 
    path = path + [start]  # source vertex included in path 
    if start == end: 
        return [path] 
    if start not in graph: 
        print("start vertex is not present in the graph") 
        return None 
    paths = [] 
    for node in graph[start]:  # iterating through graph 
        if node not in path: 
            newpaths = find_all_paths(graph, node, end, path) 
            for newpath in newpaths: 
                paths.append(newpath) 
    return paths 

find_all_paths(graph, 'A', 'D')

___________________________________________________________________________________________________

Aim:- Write a python program to implement selection sort algorithm and 
discuss the time complexity

a = list()
n = int(input("Enter the number of elements in the list: "))
print("Enter numbers in array")
for i in range(n):
    num = int(input())
    a.append(num)
print("Original list: ", a)

for i in range(len(a)):
    min_index = i
    for j in range(i+1, len(a)):
        if a[min_index] > a[j]:
            min_index = j
    a[min_index], a[i] = a[i], a[min_index]
    print("Iteration: ", i+1, a)

print("Sorted list: ", a)
print("Smallest element is: ", a[0])
print("Largest element is: ", a[-1])

___________________________________________________________________________________________

Aim:- Using Tournament method find the second largest number in the given 
list.

groups=[] 

def largest(list1): 
    global groups 
    if len(list1) == 1: 
        # print("*",list1[0]) 
        return list1[0] 
    else: 
        left = largest(list1[:len(list1)//2]) 
        # print("left",left) 
        right = largest(list1[len(list1)//2:]) 
        # print("right",right) 
        groups.append((left,right)) 
        # print("max",max (left,right)) 
        return max(left,right) 

l1 = largest([103, 10, 9, 50, 60, 30]) 
print("First Largest is:-",l1) 

s=[] 
for item in groups: 
    if l1 in item: 
        s.append(min(item)) 
print("Second largest is:-",max(s))

______________________________________________________________________________________________

Here is a Python program for implementing Huffman Coding Algorithm:

from heapq import heappush, heappop, heapify
from collections import defaultdict

def huffman_encoding(data):
    if len(data) == 0:
        return None, None

    # Step 1: Calculate the frequency of each character in the data
    freq_dict = defaultdict(int)
    for char in data:
        freq_dict[char] += 1

    # Step 2: Create a priority queue of nodes based on their frequency
    heap = [[freq, [char, ""]] for char, freq in freq_dict.items()]
    heapify(heap)

    # Step 3: Combine nodes to form a tree until there is only one node
    while len(heap) > 1:
        left = heappop(heap)
        right = heappop(heap)
        for pair in left[1:]:
            pair[1] = '0' + pair[1]
        for pair in right[1:]:
            pair[1] = '1' + pair[1]
        heappush(heap, [left[0] + right[0]] + left[1:] + right[1:])

    # Step 4: Extract the codes from the tree
    codes = dict(heappop(heap)[1:])
    
    # Step 5: Encode the data using the codes
    encoded_data = ''.join([codes[char] for char in data])

    return encoded_data, codes

def huffman_decoding(encoded_data, codes):
    if encoded_data is None or codes is None:
        return None

    # Invert the codes dictionary
    codes_inv = {v: k for k, v in codes.items()}

    # Decode the encoded data
    decoded_data = ''
    code = ''
    for bit in encoded_data:
        code += bit
        if code in codes_inv:
            decoded_data += codes_inv[code]
            code = ''

    return decoded_data

# Example Usage:
if __name__ == '__main__':
    data = "hello world"
    encoded_data, codes = huffman_encoding(data)
    print("Encoded data:", encoded_data)
    print("Codes:", codes)
    decoded_data = huffman_decoding(encoded_data, codes)
    print("Decoded data:", decoded_data)

____________________________________________________________________________________________________________

Write Python program for implementing linear search and binary search.

def linear_search(arr, x):
    """
    Perform a linear search on the given array to find the first occurrence of the given element x.
    Returns the index of the element if found, else returns -1.
    """
    for i in range(len(arr)):
        if arr[i] == x:
            return i
    return -1

def binary_search(arr, x):
    """
    Perform a binary search on the given array to find the first occurrence of the given element x.
    Returns the index of the element if found, else returns -1.
    """
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] < x:
            low = mid + 1
        else:
            high = mid - 1
    return -1

# Example Usage:
if __name__ == '__main__':
    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    x = 5
    linear_search_index = linear_search(arr, x)
    binary_search_index = binary_search(arr, x)
    print("Linear Search Result:", linear_search_index)
    print("Binary Search Result:", binary_search_index)

_______________________________________________________________________________________________________________

Write Python program to find factorial of a number using recursion.

def factorial(n):
    """
    Return the factorial of the given number n using recursion.
    """
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

# Example Usage:
if __name__ == '__main__':
    n = 5
    print("Factorial of", n, "is", factorial(n))

_____________________________________________________________________________________________________

Write Python program to display Fibonacci using recursion.

def fibonacci(n):
    """
    Return the nth Fibonacci number using recursion.
    """
    if n <= 1:
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2)

# Example Usage:
if __name__ == '__main__':
    n = 10
    print("Fibonacci Sequence:")
    for i in range(n):
        print(fibonacci(i))

_____________________________________________________________________________________________________________

Write Python program for finding the second largest element in an array A
of size n using Tournament Method.

def find_second_largest(arr):
    """
    Return the second largest element in the given array using Tournament Method.
    """
    # Create an array to hold the tournament winners
    winners = []
    # Add the elements of the input array to the winners array
    for i in range(len(arr)):
        winners.append((arr[i], i))
    
    # Keep track of the current round and the number of remaining players
    round_num = 1
    remaining_players = len(winners)
    
    # Keep playing rounds until there is only one winner left
    while remaining_players > 1:
        # Calculate the number of matches in this round
        num_matches = remaining_players // 2
        if remaining_players % 2 == 1:
            # If there is an odd number of players, add the last player to the next round
            num_matches += 1
        
        # Create an array to hold the winners of this round
        round_winners = [(0, 0)] * num_matches
        
        # Play each match and record the winner in the round_winners array
        for i in range(num_matches):
            player1 = winners[i*2]
            if i*2+1 < remaining_players:
                player2 = winners[i*2+1]
            else:
                player2 = (0, 0)
            if player1[0] > player2[0]:
                round_winners[i] = player1
            else:
                round_winners[i] = player2
        
        # Update the winners array with the winners of this round
        winners = round_winners
        remaining_players = num_matches
        round_num += 1
    
    # Find the second largest element in the original array by checking the two players in the final match
    if winners[0][1] == 0:
        return winners[1][0]
    else:
        return winners[0][0]

# Example Usage:
if __name__ == '__main__':
    arr = [5, 7, 1, 3, 9, 4, 2, 8, 6]
    second_largest = find_second_largest(arr)
    print("Array:", arr)
    print("Second Largest Element:", second_largest)

_____________________________________________________________________________________________________________

https://github.com/kibson6781/Kibson-678/blob/main/Android_Journal.pdf
https://github.com/kibson6781/Kibson-678/blob/main/FOA_Journal%5B1%5D.pdf
https://github.com/kibson6781/Kibson-678/blob/main/FOA%20PRACTICAL%20(1234%20get%20on).pdf

_____________________________________________________________________________________________________________

pip install openai

import openai
import os

# Set your OpenAI API key as an environment variable
openai.api_key = "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"


# Define your prompt
prompt = "Write a python program to implement matrix multiplication "

# Generate a response from ChatGPT
response = openai.Completion.create(
    engine="davinci", prompt=prompt, max_tokens=1024, n=1,stop=None,temperature=0.7
)

# Print the response text
print(response.choices[0].text)

