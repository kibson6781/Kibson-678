Aim:-Write a program to implement matrix multiplication and discuss the time 
complexity of the algorithm.

m = int(input("Enter number of rows matrix1: "))
n = int(input("Enter number of columns matrix1: "))

mat1 = []

# creating no of rows for
for i in range(0, m):
    mat1.append([])

# creating no of columns for every rows
for i in range(0, m):
    for j in range(0, n):
        mat1[i].append(0)
        print("Entry in row:", i+1, "Column:", j+1)
        mat1[i][j] = int(input())

print(mat1)

p = int(input("Enter number of rows matrix2: "))
q = int(input("Enter number of columns matrix2: "))

mat2 = []

# creating no of rows for
for i in range(0, p):
    mat2.append([])

# creating no of columns for every rows
for i in range(0, p):
    for j in range(0, q):
        mat2[i].append(0)
        print("Entry in row:", i+1, "Column:", j+1)
        mat2[i][j] = int(input())

print(mat2)

if n != p:
    print("Multiplication not possible")
else:
    mat3 = []
    for i in range(0, m):
        mat3.append([])
        for j in range(0, q):
            mat3[i].append(0)
            for k in range(0, n):
                mat3[i][j] += mat1[i][k] * mat2[k][j]

    print("Multiplication result:")
    for row in mat3:
        print(row)

_______________________________________________________________________________________________________

Aim:-Write a program to implement quick sort algorithm and discuss the time 
complexity of the algorithm.

def quicksort(testlist, start, end):
    if start < end:
        pivot = partition(testlist, start, end)
        quicksort(testlist, start, pivot-1)
        quicksort(testlist, pivot+1, end)
    return testlist

def partition(testlist, start, end):
    pivot = testlist[end]
    i = start-1
    for j in range(start, end):
        if testlist[j] <= pivot:
            i += 1
            testlist[i], testlist[j] = testlist[j], testlist[i]
    testlist[i+1], testlist[end] = testlist[end], testlist[i+1]
    return i+1

list1 = [9,-3,5,2,6,8,-6,1,3]
print("List before sorting:", list1)
sorted_list = quicksort(list1, 0, len(list1)-1)
print("List after sorting:", sorted_list)

__________________________________________________________________________________________________

Aim:- Write a program to implement merge sort algorithm and discuss the 
time complexity of the algorithm.

def mergesort(mylist):
    print("Dividing:",mylist)
    if(len(mylist)>1):
        mid=len(mylist)//2
        Leftlist=mylist[:mid]
        Rightlist=mylist[mid:]
        mergesort(Leftlist)
        mergesort(Rightlist)
        i=0
        j=0
        k=0
        while(i<len(Leftlist) and (j<len(Rightlist))):
            if Leftlist[i]<=Rightlist[j]:
                mylist[k]=Leftlist[i]
                i=i+1
            else:
                mylist[k]=Rightlist[j]
                j=j+1
            k=k+1
        while i<len(Leftlist):
            mylist[k]=Leftlist[i]
            i=i+1
            k=k+1
        while j<len(Rightlist):
            mylist[k]=Rightlist[j]
            j=j+1
            k=k+1
        print("merging:",mylist)
    return mylist

num=int(input("How many number you want in list:"))
list1=[int(input())for x in range(num)]
mergesort(list1)
print("Sorted list: ",list1)

________________________________________________________________________________________________

Aim:-Write a program to implement Linear Search algorithm and discuss the 
time complexity of the algorithm.

def linearsearch(mylist, n, x):
    for i in range(n):
        if (mylist[i] == x):
            return i
    return -1

mylist = [2, 33, 45, 1, 30, 34, 56]
x = 1
n = len(mylist)
result = linearsearch(mylist, n, x)

if (result == -1):
    print("Element is not present in the list")
else:
    print("Element is present at index", result)

_________________________________________________________________________________________________

Aim:-Write a program to implement Binary Search algorithm and discuss the 
time complexity of the algorithm.

def binary_search(arr, low, high, x):
    if high >= low:
        mid = (high + low) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return binary_search(arr, low, mid - 1, x)
        else:
            return binary_search(arr, mid + 1, high, x)
    else:
        return -1

arr = [2, 3, 6, 8, 11, 13]
x = 3

print(arr)
print("X=", x)

result = binary_search(arr, 0, len(arr) - 1, x)

if result == -1:
    print("Element is not found")
else:
    print("Element is present at index", result)

_______________________________________________________________________________________________________

Aim:-Write a program to implement insertion operation on Binary Search tree 
and discuss the time complexity of the algorithm.

class Node:
    def __init__(self, index):
        self.left = None
        self.right = None
        self.val = index

def insert(root, newnode):
    if root is None:
        root = newnode
    else:
        if root.val <= newnode.val:
            if root.right is None:
                root.right = newnode
            else:
                insert(root.right, newnode)
        elif root.val == newnode.val:
            print("Already existing node ", newnode.val)
        else:
            if root.left is None:
                root.left = newnode
            else:
                insert(root.left, newnode)

def inorder(root):
    if root:
        if root.val is None:
            print(end="")
        else:
            inorder(root.left)
            print(root.val)
            inorder(root.right)

def preorder(root):
    if root:
        if root.val is None:
            print(end="")
        else:
            print(root.val)
            preorder(root.left)
            preorder(root.right)

def postorder(root):
    if root:
        if root.val is None:
            print(end="")
        else:
            postorder(root.left)
            postorder(root.right)
            print(root.val)

root = Node(100)
insert(root, Node(60))
insert(root, Node(50))
insert(root, Node(90))
insert(root, Node(40))
insert(root, Node(53))
insert(root, Node(95))
insert(root, Node(75))

print("Inorder Traversal:")
inorder(root)

print("Preorder Traversal:")
preorder(root)

print("Postorder Traversal:")
postorder(root)

print("\n")

__________________________________________________________________________________________

Aim:- Write a python program to delete node from the binary tree from a 
given data and discuss the time complexity.

class Node:
    def __init__(self, index):
        self.left = None
        self.right = None
        self.val = index

def insert(root, newnode):
    if root is None:
        root = newnode
    else:
        if root.val <= newnode.val:
            if root.right is None:
                root.right = newnode
            else:
                insert(root.right, newnode)
        elif root.val == newnode.val:
            print("Already existing node ", newnode.val)
        else:
            if root.left is None:
                root.left = newnode
            else:
                insert(root.left, newnode)

def inorder(root):
    if root:
        if root.val is None:
            print(end="")
        else:
            inorder(root.left)
            print(root.val, end=" ")
            inorder(root.right)

def preorder(root):
    if root:
        if root.val is None:
            print(end="")
        else:
            print(root.val, end=" ")
            preorder(root.left)
            preorder(root.right)

def postorder(root):
    if root:
        if root.val is None:
            print(end="")
        else:
            postorder(root.left)
            postorder(root.right)
            print(root.val, end=" ")

def delete(root, node1):
    if root is None:
        print("Empty tree")
    elif root.val < node1:
        delete(root.right, node1)
    elif root.val > node1:
        delete(root.left, node1)
    else:
        root.val = None

root = Node(100)
insert(root, Node(60))
insert(root, Node(50))
insert(root, Node(90))
insert(root, Node(40))
insert(root, Node(53))
insert(root, Node(95))
insert(root, Node(75))

print("Before Deletion Operation:")
print("Inorder Traversal:")
inorder(root)
print("\nPreorder Traversal:")
preorder(root)
print("\nPostorder Traversal:")
postorder(root)
print("\n")

delete(root, 40)
delete(root, 90)

print("After Deletion Operation:")
print("Inorder Traversal:")
inorder(root)
print("\nPreorder Traversal:")
preorder(root)
print("\nPostorder Traversal:")
postorder(root)

____________________________________________________________________________________________________

Aim:- Write a python program to implement Breadth First Traversal of graph.

def bfs(visited, graph, node): 
    visited.append(node) 
    queue = [node]
    while queue: 
        m = queue.pop(0) 
        print(m, end=" ") 
        for neighbour in graph[m]: 
            if neighbour not in visited: 
                visited.append(neighbour) 
                queue.append(neighbour) 

graph = { 
    'A': ['B', 'D', 'G'], 
    'B': ['A', 'C', 'D'], 
    'C': ['B', 'E', 'F'], 
    'D': ['A', 'B', 'E'], 
    'E': ['D', 'C', 'F', 'G'], 
    'F': ['C', 'E', 'H'], 
    'G': ['A', 'E', 'H'], 
    'H': ['G', 'F'], 
} 

visited=[] 
print("Following is Breadth-First Search") 
bfs(visited,graph,'A')

______________________________________________________________________________________________________

Aim:- Write a python program to implement Depth First Traversal of graph.

graph = { 
    'A': ['B', 'D', 'G'], 
    'B': ['A', 'C', 'D'], 
    'C': ['B', 'E', 'F'], 
    'D': ['A', 'B', 'E'], 
    'E': ['D', 'C', 'F', 'G'], 
    'F': ['C', 'E', 'H'], 
    'G': ['A', 'E', 'H'], 
    'H': ['G', 'F']
}
visited = set()

def dfs(visited, graph, node):
    if node not in visited:
        print(node, end=" ")
        visited.add(node)
        for neighbour in graph[node]:
            dfs(visited, graph, neighbour)

print("Following is the Depth-First Search")
dfs(visited, graph, 'A')

___________________________________________________________________________________________________

Aim:- Write python program for checking whether a given graph g has a simple 
path from source s to destination d

graph = {'A': ['B', 'C'], 
         'B': ['C', 'D'], 
         'C': ['D'], 
         'D': ['C'], 
         'E': ['F'], 
         'F': ['C']} 

def find_all_paths(graph, start, end, path=[]): 
    path = path + [start]  # source vertex included in path 
    if start == end: 
        return [path] 
    if start not in graph: 
        print("start vertex is not present in the graph") 
        return None 
    paths = [] 
    for node in graph[start]:  # iterating through graph 
        if node not in path: 
            newpaths = find_all_paths(graph, node, end, path) 
            for newpath in newpaths: 
                paths.append(newpath) 
    return paths 

find_all_paths(graph, 'A', 'D')

___________________________________________________________________________________________________

Aim:- Write a python program to implement selection sort algorithm and 
discuss the time complexity

a = list()
n = int(input("Enter the number of elements in the list: "))
print("Enter numbers in array")
for i in range(n):
    num = int(input())
    a.append(num)
print("Original list: ", a)

for i in range(len(a)):
    min_index = i
    for j in range(i+1, len(a)):
        if a[min_index] > a[j]:
            min_index = j
    a[min_index], a[i] = a[i], a[min_index]
    print("Iteration: ", i+1, a)

print("Sorted list: ", a)
print("Smallest element is: ", a[0])
print("Largest element is: ", a[-1])

___________________________________________________________________________________________

Aim:- Using Tournament method find the second largest number in the given 
list.

groups=[] 

def largest(list1): 
    global groups 
    if len(list1) == 1: 
        # print("*",list1[0]) 
        return list1[0] 
    else: 
        left = largest(list1[:len(list1)//2]) 
        # print("left",left) 
        right = largest(list1[len(list1)//2:]) 
        # print("right",right) 
        groups.append((left,right)) 
        # print("max",max (left,right)) 
        return max(left,right) 

l1 = largest([103, 10, 9, 50, 60, 30]) 
print("First Largest is:-",l1) 

s=[] 
for item in groups: 
    if l1 in item: 
        s.append(min(item)) 
print("Second largest is:-",max(s))

______________________________________________________________________________________________

