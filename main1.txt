1.Write a program to implement matrix multiplication and discuss the time complexity of the algorithm.
2.Write a program to implement quick sort algorithm and discuss the time complexity of the algorithm.
3.Write a program to implement merge sort algorithm and discuss the time complexity of the algorithm.
4.Write a python program to implement the linear search algorithm and discuss the time complexity of the algorithm.
5.Write a python program to implement binary search algorithm and discuss the time complexity of the algorithm.
6.Write a python program to implement Insertion operation on binary search tree and discuss the time complexity of the algorithm.
7.Write a python program to delete node from the binary tree from a given data and discuss the time complexity of the algorithm.
8.Write a python program to implement Breadth First Traversal of graph.
9.Write a python program to implement Depth First Traversal of graph.
10.Write a python program for checking whether a given graph g has a simple path from source s to destination d.
11.Write a python program to implement selection sort algorithm and discuss the time complexity.
12.Using Tournament method find the second largest number in the given list.

Practical No.1

m=int (input("Enter number of rows matrix 1: "))
n=int (input("Enter number of coln matrix 1: "))
mat1=[]

for i in range(0,m):
    mat1.append([])

for i in range(0,m):
    for j in range(0,n):
        mat1[i].append(j)

        mat1[i][j]=0
        
        print("Entry in row:", i+1, "column:", j+1)
        mat1[i][j]=int(input())

print(mat1)

p=int (input("Enter number of rows matrix 2: "))
q=int (input("Enter number of coln matrix 2: "))
mat2=[]

for i in range(0,p):
    mat2.append([])

for i in range(0,p):
    for j in range(0,q):
        mat2[i].append(j)

        mat2[i][j]=0
        
        print("Entry in row:", i+1, " and column:", j+1)
        mat2[i][j]=int(input())

print(mat2)
res=[]

for i in range(0,m):
    res.append([])
for i in range (0,m):
    for j in range (0,q):
        res[i].append(j)
        res[i][j]=0

print("Multiplication Result:")
if n!=p:
    print("Multiplication is not possible")
else:
    for p in range (len(mat1)):
        for q in range (len(mat2[0])):
            for r in range(len(mat2)):
                res[p][q]+=mat1[p][r]*mat2[r][q]
print (res)

Practical No.2

def partition(array, low, high):
    pivot = array[high]
    i = low - 1
    for j in range(low, high):
        if array[j] <= pivot:
            i = i + 1
            (array[i], array[j]) = (array[j], array[i])
    (array[i + 1], array[high]) = (array[high], array[i + 1])
    return i + 1
def quickSort(array, low, high):
    if low < high:
        pi = partition(array, low, high)
        quickSort(array, low, pi - 1)
        quickSort(array, pi + 1, high)
data = [0, 4, 6, 9, 1, 2]        
print("Unsorted Array")
print(data)
size = len(data) 
quickSort(data, 0, size - 1)
print('Sorted Array in Ascending Order:')
print(data)

Practical No.3

def MergeSort(mylist):
    print("Dividing:",mylist)
    if(len(mylist)>1):
        mid=len(mylist)//2
        leftlist=mylist[:mid]
        rightlist=mylist[mid:]
        MergeSort(leftlist)
        MergeSort(rightlist)
        i=0
        j=0
        k=0
        while i<len(leftlist) and j<len(rightlist):
            if leftlist[i]<=rightlist[j]:
                mylist[k]=leftlist[i]
                i=i+1
            else:
                mylist[k]=rightlist[j]
                j=j+1
            k=k+1
           
        while i<len(leftlist):
            mylist[k]=leftlist[i]
            i=i+1
            k=k+1
        while j<len(rightlist):
            mylist[k]=rightlist[j]
            j=j+1
            k=k+1
    print("Merging:",mylist)
    return mylist
num=int(input("How many number you want in the list: "))
list1=[int(input())for x in range(num)]
MergeSort(list1)
print("Sorted List is:",list1)

Practical No.4

def linearsearch(testlist,start,end,num):
    if (start<end):
        temp=start
        for i in range(start, end+1):
            if testlist[temp]==num:
                return(f"Search Item {num} found at index {temp}")
            else:
                temp+=1
    else:
        if(testlist[0]==num):
            return("Search found at index 0 in a list of 1 item.")
        else:
            return("Search item not found in list.")
        
arr=[2,3,4,5,6,7,8,9]
print(linearsearch(arr,0,len(arr)-1,8))

Practical No.5

def MergeSort(mylist):
    print("Dividing:",mylist)
    if(len(mylist)>1):
        mid=len(mylist)//2
        leftlist=mylist[:mid]
        rightlist=mylist[mid:]
        MergeSort(leftlist)
        MergeSort(rightlist)
        i=0
        j=0
        k=0
        while i<len(leftlist) and j<len(rightlist):
            if leftlist[i]<=rightlist[j]:
                mylist[k]=leftlist[i]
                i=i+1
            else:
                mylist[k]=rightlist[j]
                j=j+1
            k=k+1
           
        while i<len(leftlist):
            mylist[k]=leftlist[i]
            i=i+1
            k=k+1
        while j<len(rightlist):
            mylist[k]=rightlist[j]
            j=j+1
            k=k+1
    print("Merging:",mylist)
    return mylist
num=int(input("How many number you want in the list: "))
list1=[int(input())for x in range(num)]
MergeSort(list1)
print("Sorted List is:",list1)

Practical No.6

class Node:
    def __init__(self,index):
        self.left=None
        self.right=None
        self.val=index
def insert(root,newnode):
    if root is None:
        root=newnode
    else:
        if root.val<newnode.val:
            if root.right is None:
                root.right=newnode
            else:
                insert(root.right,newnode)
        elif root.val==newnode.val:
            print("Already present",newnode.val)
        else:
            if root.left is None:
                root.left=newnode
            else:
                insert(root.left,newnode)
def inorder(root):
    if root:
        if root.val==None:
            print(end="")
        else:
            inorder(root.left)
            print(root.val)
            inorder(root.right)
def preorder(root):
    if root:
        if root.val==None:
            print(end="")
        else:
            preorder(root.left)
            print(root.val)
            preorder(root.right)
def postorder(root):
    if root:
        if root.val==None:
            print(end="")
        else:
            postorder(root.left)
            print(root.val)
            postorder(root.right)
def delete(root,node1):
    if root is None:
        print("Empty tree")
    elif root.val<node1:
        delete(root.right,node1)
    elif root.val>node1:
        delete(root.left,node1)
    else:
        root.val=None
r=Node(20)
insert(r,Node(30))
insert(r,Node(90))
insert(r,Node(80))
insert(r,Node(40))
insert(r,Node(23))
insert(r,Node(150))
insert(r,Node(65))
insert(r,Node(1600))
insert(r,Node(130))
delete(r,40)
print("inorder Traversal:")
inorder(r)
print("preorder Traversal:")
preorder(r)
print("postorder Traversal:")
postorder(r)

Practical No.7

class Node:
    def __init__(self,index):
        self.index=index
        self.left=None
        self.right=None

def insert(node,index):
    if node is None:
        return Node(index)
    if index<node.index:
        node.left=insert(node.left,index)
    else:
        node.right=insert(node.right,index)
    return node

def searchminode(node):
    current = node
    while current.left is not None:
        current=current.left
    return current

def inorder(root):
    if root is not None:
        inorder(root.left)
        print(root.index)
        inorder(root.right)

def deletenode(root,index):
    if root is None:
        return root
    if (index<root.index):
        root.left=deletenode(root.left,index)
    elif (index>root.index):
        root.right=deletenode(root.right,index)
    else:
        if root.left is None:
            temp=root.right
            root=None
            return temp
        elif root.right is None:
            temp=root.left
            root=None
            return temp
        temp=searchminode(root.right)
        root.index=temp.index
        root.right=deletenode(root.right,temp.index)
    return root

root=None
root=insert(root,100)
root=insert(root,20)
root=insert(root,10)
root=insert(root,50)
root=insert(root,120)
root=insert(root,102)
root=insert(root,180)


print("Inorder Traversal of a tree is: ")
inorder(root)
print("********")
print("After deleting the node 180")
root=deletenode(root,180)
inorder(root)

Practical No.8

import collections
def bfs(graph, root):
    visited, queue = set(), collections.deque([root])
    visited.add(root)
    while queue:
        vertex = queue.popleft()
        print(str(vertex) + " ", end="")
        for neighbour in graph[vertex]:
            if neighbour not in visited:
                visited.add(neighbour)
                queue.append(neighbour)
if __name__== '__main__':
    graph = {0: [0, 1], 1: [0, 2], 2: [1, 2], 3: [3, 3]}
    print("Following is Breadth First Traversal: ")
    bfs(graph,2)

Practical No.9

def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start)
    for next in graph[start] - visited:
        dfs(graph, next, visited)
    return visited


graph = {'0': set(['2']),
         '1': set(['2', '3']),
         '2': set(['4', '0', '1']),
         '3': set(['1', '4']),
         '4': set(['2', '3']),
        }

dfs(graph, '2')

Practical No.10

# A-->B
# A-->C
# B-->C
# B-->D
# C-->D
# D-->C
# E-->F
# F-->C
# A-B-C-D

graph={'A':['B','C'],
       'B':['C','D'],
       'C':['D'],
       'D':['C'],
       'E':['F'],
       'F':['C']}

# start =A , end =B

def find_all_paths(graph,start,end,path=[]):
    path=path+[start]
    print(path)
    if start==end:
        return [path]
    if start not in graph:
        print("Start vertex is not present in the graph")
        return None
    paths=[]
    for node in graph[start]:
        if node not in path:
            newpaths=find_all_paths(graph,node, end, path)
            print(newpaths)
            for newpath in newpaths:
                paths.append(newpath)
    return paths

Output :
write find_all_paths(grpah,'A','D')

Practical No.11

a=list()
n=int(input("Enter No. of Elements in the List : "))
print("Enter the numbers of Array")
for i in range(n):
    num=input()
    a.append(int(num))
print(a)
    
for i in range(len(a)):
    min_ind=i
    for j in range(i+1,len(a)):
        if a[min_ind]>a[j]:
            min_ind=j
    a[min_ind],a[i]=a[i],a[min_ind]
    print("Iterations : ",(i+1))
    print(a)
    
print("Smallest Element is : ",a[0])
print("Largest Element is : ",a[len(a)-1])

Practical No.12

groups=[]
def largest(list1):
    global groups
    
    if  len(list1)==1:
        print("*",list1[0])
        return list1[0]
    else:
        left=largest(list1[:len(list1)//2])
        print("left",left)
        right=largest(list1[len(list1)//2:])
        print("right",right)
        groups.append((left,right))
        return max(left,right)
        print(groups)
        print("max",max(left,right))
            
l1=largest([3,10,9,50,60,30])
print("First Largest is:",l1)
s=[]
for item in  groups:
    if l1 in item:
        s.append(min(item))
print("Second largest is:",max(s))
