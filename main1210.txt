#Aim: Implementation of Simple Search 1

import random

OPEN = ['S']
map_list = {
    'S': ['A', 'B', 'C'],
    'A': ['S', 'D'],
    'B': ['S', 'E'],
    'C': ['S', 'F'],
    'D': ['A', 'G'],
    'E': ['B', 'G', 'F'],
    'F': ['C', 'E'],
    'G': ['D', 'E']
}

def movegen(node):
    return map_list[node]

def goaltest(node):
    return node == 'G'

def ss1():
    while len(OPEN) > 0:
        random.shuffle(OPEN)
        N = OPEN.pop()
        if goaltest(N):
            return "Found"
        else:
            n = movegen(N)
            for i in n:
                if i not in OPEN:
                    OPEN.append(i)
            print("OPEN_LIST", OPEN)
    return "NOT Found"

print(ss1())

--------------------------------------------------------------------------------------------------------------------------------------------------------------
#Aim: Implementation of Simple Search 2

import random

OPEN = ['S']
CLOSED = []
map_list = {
    'S': ['A', 'B', 'C'],
    'A': ['S', 'D'],
    'B': ['S', 'E'],
    'C': ['S', 'F'],
    'D': ['A', 'G'],
    'E': ['B', 'G', 'F'],
    'F': ['C', 'E'],
    'G': ['D', 'E']
}

def movegen(node):
    return map_list[node]

def goaltest(node):
    return node == 'G'

def ss2():
    while len(OPEN) > 0:
        random.shuffle(OPEN)
        N = OPEN.pop()
        CLOSED.append(N)
        if goaltest(N):
            return "Found"
        else:
            n = movegen(N)
            for i in n:
                if i not in OPEN and i not in CLOSED:
                    OPEN.append(i)
            print("OPEN_LIST", OPEN)
            print("CLOSED_LIST", CLOSED)
    return "NOT Found"

print(ss2())

-----------------------------------------------------------------------------------------------------------------------------------------------------
# Aim: Implementation of Simple Search 3

import random

OPEN = [['S', None]]
CLOSED = []
map_list = {
    'S': ['A', 'B', 'C'],
    'A': ['S', 'D'],
    'B': ['S', 'E'],
    'C': ['S', 'F'],
    'D': ['A', 'G'],
    'E': ['B', 'G', 'F'],
    'F': ['C', 'E'],
    'G': ['D', 'E']
}

def movegen(node):
    return map_list[node]

def goaltest(node):
    return node == 'G'

def returnpath(path):
    if path is not None:
        return str(path[0] + returnpath(path[1]))
    else:
        return ""

def ss3():
    while len(OPEN) > 0:
        random.shuffle(OPEN)
        print("Open list", OPEN)
        M = OPEN.pop()
        N = M[0]
        CLOSED.append(N)
        print("Picked: ", CLOSED)
        if goaltest(N):
            print("Goal Found")
            print("Path: ", returnpath(M)[::-1])
            return
        else:
            neigh = movegen(N)
            for node in neigh:
                if node not in CLOSED and node not in [x[0] for x in OPEN]:
                    new_list = [node, M]
                    OPEN.append(new_list)
    print("NOT Found")

ss3()

-----------------------------------------------------------------------------------------------------------------------------------------------------------

Aim:
To write a python program to implement Breadth First Search algorithm.

graph = {
    'S': ['A', 'B', 'C'],
    'A': ['S', 'D'],
    'B': ['S', 'E'],
    'C': ['S', 'F'],
    'D': ['A', 'G'],
    'E': ['B', 'G', 'F'],
    'F': ['C', 'E'],
    'G': ['D', 'E']
}

visited = []
queue = []

def bfs(visited, graph, node):
    visited.append(node)
    queue.append(node)
    while queue:
        m = queue.pop(0)
        print(m, end=" ")
        for neigh in graph[m]:
            if neigh not in visited:
                visited.append(neigh)
                queue.append(neigh)

bfs(visited, graph, 'S')
---------------------------------------------------------------------------------------------------------------------------------------------------------------

Aim:To write a python program to implement Depth First Search algorithm.

graph = {
    'S': ['A', 'B', 'C'],
    'A': ['S', 'D'],
    'B': ['S', 'E'],
    'C': ['S', 'F'],
    'D': ['A', 'G'],
    'E': ['B', 'G', 'F'],
    'F': ['C', 'E'],
    'G': ['D', 'E']
}

visited = []

def dfs(visited, graph, node):
    if node not in visited:
        print(node, end=" ")
        visited.append(node)
        for n in graph[node]:
            dfs(visited, graph, n)

dfs(visited, graph, 'S')

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aim:
To write a python program to implement A* Algorithm.

nodelist = {
    'mumbai': [('delhi', 1200), ('nasik', 350), ('goa', 800), ('pune', 130)],
    'delhi': [('nasik', 375), ('mumbai', 1200)],
    'nasik': [('indore', 600), ('delhi', 375), ('mumbai', 350), ('nagpur', 600)],
    'indore': [('nasik', 600)],
    'nagpur': [('nasik', 600), ('pune', 450)],
    'pune': [('mumbai', 130), ('nagpur', 450), ('blore', 550)],
    'blore': [('hyd', 110), ('goa', 750)],
    'goa': [('blore', 750), ('hyd', 850), ('mumbai', 800)],
    'hyd': [('blore', 110), ('goa', 850)]
}

hd = {
    'mumbai': 790,
    'delhi': 1515,
    'nasik': 1140,
    'indore': 1540,
    'nagpur': 1110,
    'pune': 660,
    'blore': 110,
    'goa': 850,
    'hyd': 0
}

openList = [('mumbai', 700)]
closedList = []

def goalTest(node):
    return node == 'hyd'

def moveGen(node):
    return nodelist[node[0]]

def sort(mylist):
    for i in range(len(mylist)):
        for j in range(0, len(mylist) - i - 1):
            if mylist[j][1] > mylist[j + 1][1]:
                temp = mylist[j]
                mylist[j] = mylist[j + 1]
                mylist[j + 1] = temp

def AStar():
    while len(openList) > 0:
        sort(openList)
        print("Open List Contains", openList)
        node = openList.pop(0)
        closedList.append((node[0], hd[node[0]]))
        print("Picked node", node)
        if goalTest(node[0]):
            return "Goal Found"
        else:
            neighbours = moveGen(node)
            print("Neighbours of", node[0], "are:", neighbours)
            for n in neighbours:
                if n not in openList and n[0] not in [x[0] for x in closedList]:
                    tup = (n[0], n[1] + hd[n[0]])
                    openList.append(tup)
    return "Goal Not Found"

result = AStar()
print(result)

------------------------------------------------------------------------------------------------------------------------------------------------------------

Aim:
To write a python program to implement Best First Search Algorithm.

map_list = {
    'Mumbai': [('Pune', 750), ('Delhi', 1500), ('Goa', 1300)],
    'Goa': [('Mumbai', 1200)],
    'Delhi': [('Mumbai', 1200), ('Guwahati', 100), ('Pune', 750)],
    'Chennai': [('Pune', 750)],
    'Kolkata': [('Guwahati', 100), ('Pune', 750)],
    'Pune': [('Mumbai', 1200), ('Kolkata', 0), ('Chennai', 1600), ('Delhi', 1500)],
    'Guwahati': [('Delhi', 1500), ('Kolkata', 0)]
}

OPEN = [[('Mumbai', 1200), None]]
CLOSED = []

def movegen(node):
    return map_list[node]

def goaltest(node):
    return node == 'Kolkata'

final = []

def reconstructpath(path):
    if path is None:
        return ""
    else:
        final.append(path[0][0])
        reconstructpath(path[1])
    return final

def sort(a):
    for i in range(len(a)):
        for j in range(0, len(a) - i - 1):
            if a[j][0][1] > a[j + 1][0][1]:
                a[j], a[j + 1] = a[j + 1], a[j]
    return a

def best():
    while len(OPEN) > 0:
        print("Open List: ", OPEN)
        x = sort(OPEN)
        seen = x.pop(0)
        N = seen[0][0]
        CLOSED.append(N)
        print("Closed list contains ", CLOSED)
        print("Node Picked: ", N)
        if goaltest(N):
            print(reconstructpath(seen)[::-1])
            return "Found"
        else:
            neigh = movegen(N)
            for i in neigh:
                if i[0] not in CLOSED and i not in OPEN:
                    new = [i, seen]
                    OPEN.append(new)
    return "Not Found"

result = best()
print(result)

------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aim:
To write a python program to implement Decision Tree Learning.

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score

# Load the dataset
balance_data = pd.read_csv('C:/Users/sies/Desktop/balance-scale.data', sep=',', header=None)
print("Dataset Length:", len(balance_data))
print("Dataset Shape:", balance_data.shape)
print(balance_data.head())

# Split the dataset into features (X) and target (Y)
X = balance_data.values[:, 1:5]
Y = balance_data.values[:, 0]

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.4, random_state=100)

# Create Decision Tree classifiers with different criteria
clf_entropy = DecisionTreeClassifier(criterion="entropy", random_state=100, max_depth=3, min_samples_leaf=5)
clf_entropy.fit(X_train, y_train)

clf_gini = DecisionTreeClassifier(criterion="gini", random_state=100, max_depth=3, min_samples_leaf=5)
clf_gini.fit(X_train, y_train)

# **Correct the following line**
# Predict the target values using the trained classifiers
y_pred_en = clf_entropy.predict(X_test)
y_pred_gini = clf_gini.predict(X_test)

# Print the results
print("Actual Target Values (y_test):", y_test)
print("Predicted Target Values (Entropy Criterion):", y_pred_en)
print("Predicted Target Values (Gini Criterion):", y_pred_gini)

# Calculate and print the accuracy of the predictions
accuracy_entropy = accuracy_score(y_pred_en, y_test) * 100
accuracy_gini = accuracy_score(y_pred_gini, y_test) * 100
print("Accuracy (Entropy Criterion):", accuracy_entropy)
print("Accuracy (Gini Criterion):", accuracy_gini)

----------------------------------------------------------------------------------------------------------------------------------------------------
Practical:9
Aim: To implement Support Vector Machine Algorithm in Python

# Importing required libraries
import numpy as np
import matplotlib.pyplot as plt
from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score

# Create a synthetic dataset
X, y = datasets.make_classification(n_samples=100, n_features=2, n_classes=2, n_clusters_per_class=1, n_informative=2, random_state=42)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create an SVM classifier with a linear kernel
clf = SVC(kernel='linear')

# Train the SVM classifier
clf.fit(X_train, y_train)

# Make predictions on the test set
y_pred = clf.predict(X_test)

# Calculate accuracy
accuracy = accuracy_score(y_test, y_pred)
print(f'Accuracy: {accuracy}')

# Plot the decision boundary
plt.scatter(X[:, 0], X[:, 1], c=y, cmap=plt.cm.Paired)
ax = plt.gca()
xlim = ax.get_xlim()
ylim = ax.get_ylim()
xx, yy = np.meshgrid(np.linspace(xlim[0], xlim[1], 50), np.linspace(ylim[0], ylim[1], 50))
Z = clf.decision_function(np.c_[xx.ravel(), yy.ravel()])
Z = Z.reshape(xx.shape)
plt.contour(xx, yy, Z, colors='k', levels=[-1, 0, 1], alpha=0.5, linestyles=['--', '-', '--'])
plt.scatter(clf.support_vectors_[:, 0], clf.support_vectors_[:, 1], s=100, linewidth=1, facecolors='none', edgecolors='k')
plt.title('Support Vector Machine Decision Boundary')
plt.xlabel('Feature 1')
plt.ylabel('Feature 2')
plt.show()


https://github.com/kibson6781/Kibson-678/blob/main/AI%20Practical%20Journal(TCS2223077).pdf
https://github.com/kibson6781/Kibson-678/blob/main/TCS2324045%20AI%20JOURNAL_removed.pdf


import pandas
from sklearn import model_selection
from sklearn.ensemble import AdaBoostClassifier

# Load the dataset
url = "https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv"
names = ['preg', 'plas', 'pres', 'skin', 'test', 'mass', 'pedi', 'age', 'class']
dataframe = pandas.read_csv(url, names=names)

# Prepare the dataset
array = dataframe.values
X = array[:, 0:8]
Y = array[:, 8]

# Set the random seed and number of trees
seed = 7
num_trees = 30

# Split the training data into smaller samples using k-fold cross-validation
kfold = model_selection.KFold(n_splits=10)

# Create the AdaBoost model
model = AdaBoostClassifier(n_estimators=num_trees, random_state=seed)

# Evaluate the model using cross-validation
results = model_selection.cross_val_score(model, X, Y, cv=kfold)

# Print the mean accuracy
print("Mean Accuracy: {:.2f}%".format(results.mean() * 100))


# Import necessary libraries
from sklearn.model_selection import train_test_split
from sklearn import metrics
from sklearn import svm
from sklearn import datasets

# Load the breast cancer dataset
cancer_data = datasets.load_breast_cancer()

# Split the dataset into training and testing sets
x_train, x_test, y_train, y_test = train_test_split(cancer_data.data, cancer_data.target, test_size=0.4, random_state=189)

# Create a Support Vector Classifier (SVC) with a linear kernel
cls = svm.SVC(kernel="linear")

# Train the model
cls.fit(x_train, y_train)

# Predict the responses
y_pred = cls.predict(x_test)

# Calculate accuracy
accuracy = metrics.accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)

# Print classification report
classification_report = metrics.classification_report(y_test, y_pred)
print(classification_report)


import random

# Define the map and the goal node
graph = {
    'S': ['A', 'B', 'C'],
    'A': ['S', 'D'],
    'B': ['S', 'E'],
    'C': [],
    'D': ['A', 'G'],
    'E': ['B', 'G', 'F'],
    'F': ['C', 'E'],
    'G': ['D', 'E']
}

goal_node = 'G'

# Define the move generator function
def movegen(node):
    return graph.get(node, [])

# Define the goal test function
def goaltest(node):
    return node == goal_node

# Simple search function
def ss1():
    open_list = ['S']

    while open_list:
        random.shuffle(open_list)
        n = open_list.pop()
        
        if goaltest(n):
            return "FOUND"
        else:
            moves = movegen(n)
            for i in moves:
                if i not in open_list:
                    open_list.append(i)
    
    return "NOT FOUND"

print(ss1())
